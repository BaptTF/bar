/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI - Bar
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.11
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'google_id': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'google_picture': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'email_address': string;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'balance': number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'card_id': string;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'card_pin': string;
    /**
     * 
     * @type {AccountRole}
     * @memberof Account
     */
    'role': AccountRole;
    /**
     * 
     * @type {Array<AccountRestrictions>}
     * @memberof Account
     */
    'restrictions': Array<AccountRestrictions>;
    /**
     * 
     * @type {AccountState}
     * @memberof Account
     */
    'state': AccountState;
    /**
     * 
     * @type {number}
     * @memberof Account
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Account
     */
    'deleted_by'?: string;
}


/**
 * Restrictions of the account
 * @export
 * @enum {string}
 */

export const AccountRestrictions = {
    AccountRemoteRestricted: 'remote_restricted',
    AccountBlocked: 'blocked'
} as const;

export type AccountRestrictions = typeof AccountRestrictions[keyof typeof AccountRestrictions];


/**
 * Role of the account
 * @export
 * @enum {string}
 */

export const AccountRole = {
    AccountStudent: 'student',
    AccountStudentWithBenefits: 'student_with_benefits',
    AccountMember: 'member',
    AccountAdmin: 'admin',
    AccountGhost: 'ghost',
    AccountSuperAdmin: 'superadmin'
} as const;

export type AccountRole = typeof AccountRole[keyof typeof AccountRole];


/**
 * State of the account
 * @export
 * @enum {string}
 */

export const AccountState = {
    AccountOk: 'account_ok'
} as const;

export type AccountState = typeof AccountState[keyof typeof AccountState];


/**
 * 
 * @export
 * @interface CarouselImage
 */
export interface CarouselImage {
    /**
     * 
     * @type {string}
     * @memberof CarouselImage
     */
    'id': string;
    /**
     * Image to display
     * @type {string}
     * @memberof CarouselImage
     */
    'image_url': string;
    /**
     * 
     * @type {number}
     * @memberof CarouselImage
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof CarouselImage
     */
    'deleted_by'?: string;
}
/**
 * 
 * @export
 * @interface CarouselText
 */
export interface CarouselText {
    /**
     * 
     * @type {string}
     * @memberof CarouselText
     */
    'id': string;
    /**
     * Text to display
     * @type {string}
     * @memberof CarouselText
     */
    'text': string;
    /**
     * Color of the text
     * @type {string}
     * @memberof CarouselText
     */
    'color': string;
    /**
     * 
     * @type {number}
     * @memberof CarouselText
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof CarouselText
     */
    'deleted_by'?: string;
}
/**
 * 
 * @export
 * @interface CarouselTextCreate
 */
export interface CarouselTextCreate {
    /**
     * Text to display
     * @type {string}
     * @memberof CarouselTextCreate
     */
    'text': string;
    /**
     * Color of the text
     * @type {string}
     * @memberof CarouselTextCreate
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'id': string;
    /**
     * Name of the current category
     * @type {string}
     * @memberof Category
     */
    'name': string;
    /**
     * Link to picture of the current category
     * @type {string}
     * @memberof Category
     */
    'picture_uri': string;
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'deleted_by'?: string;
}
/**
 * 
 * @export
 * @interface ConnectCard200Response
 */
export interface ConnectCard200Response {
    /**
     * 
     * @type {Messages}
     * @memberof ConnectCard200Response
     */
    'message'?: Messages;
    /**
     * 
     * @type {Account}
     * @memberof ConnectCard200Response
     */
    'account'?: Account;
}


/**
 * 
 * @export
 * @interface ConnectCardRequest
 */
export interface ConnectCardRequest {
    /**
     * 
     * @type {string}
     * @memberof ConnectCardRequest
     */
    'card_id': string;
    /**
     * 
     * @type {string}
     * @memberof ConnectCardRequest
     */
    'card_pin': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorCodes = {
    ErrBadRequest: 'bad_request',
    ErrForbidden: 'forbidden',
    ErrAccountNotFound: 'account_not_found',
    ErrQRInvalid: 'qr_invalid',
    ErrInternalServerError: 'internal_server_error',
    ErrNotAuthenticated: 'not_authenticated',
    ErrImageNotFound: 'image_not_found',
    ErrTextNotFound: 'text_not_found',
    ErrCategoryNotFound: 'category_not_found',
    ErrItemNotFound: 'item_not_found',
    ErrRefillNotFound: 'refill_not_found',
    ErrTransactionNotFound: 'transaction_not_found'
} as const;

export type ErrorCodes = typeof ErrorCodes[keyof typeof ErrorCodes];


/**
 * 
 * @export
 * @interface GetAccountAdmin200Response
 */
export interface GetAccountAdmin200Response {
    /**
     * 
     * @type {Messages}
     * @memberof GetAccountAdmin200Response
     */
    'message'?: Messages;
    /**
     * 
     * @type {boolean}
     * @memberof GetAccountAdmin200Response
     */
    'is_allowed': boolean;
}


/**
 * 
 * @export
 * @interface GetAccountQRRequest
 */
export interface GetAccountQRRequest {
    /**
     * 
     * @type {string}
     * @memberof GetAccountQRRequest
     */
    'card_pin': string;
}
/**
 * 
 * @export
 * @interface GetAccounts200Response
 */
export interface GetAccounts200Response {
    /**
     * 
     * @type {Messages}
     * @memberof GetAccounts200Response
     */
    'message'?: Messages;
    /**
     * 
     * @type {Array<Account>}
     * @memberof GetAccounts200Response
     */
    'accounts': Array<Account>;
    /**
     * 
     * @type {number}
     * @memberof GetAccounts200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetAccounts200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetAccounts200Response
     */
    'max_page': number;
}


/**
 * 
 * @export
 * @interface GetCategoryItems200Response
 */
export interface GetCategoryItems200Response {
    /**
     * 
     * @type {Array<Item>}
     * @memberof GetCategoryItems200Response
     */
    'items'?: Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof GetCategoryItems200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCategoryItems200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetCategoryItems200Response
     */
    'max_page'?: number;
}
/**
 * 
 * @export
 * @interface GetDeletedAccounts200Response
 */
export interface GetDeletedAccounts200Response {
    /**
     * 
     * @type {Array<Account>}
     * @memberof GetDeletedAccounts200Response
     */
    'accounts': Array<Account>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedAccounts200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedAccounts200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedAccounts200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetDeletedCarouselImages200Response
 */
export interface GetDeletedCarouselImages200Response {
    /**
     * 
     * @type {Array<CarouselImage>}
     * @memberof GetDeletedCarouselImages200Response
     */
    'items': Array<CarouselImage>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselImages200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselImages200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselImages200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetDeletedCarouselTexts200Response
 */
export interface GetDeletedCarouselTexts200Response {
    /**
     * 
     * @type {Array<CarouselText>}
     * @memberof GetDeletedCarouselTexts200Response
     */
    'items': Array<CarouselText>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselTexts200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselTexts200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedCarouselTexts200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetDeletedItems200Response
 */
export interface GetDeletedItems200Response {
    /**
     * 
     * @type {Array<Item>}
     * @memberof GetDeletedItems200Response
     */
    'items': Array<Item>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedItems200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedItems200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedItems200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetDeletedRefills200Response
 */
export interface GetDeletedRefills200Response {
    /**
     * 
     * @type {Array<Refill>}
     * @memberof GetDeletedRefills200Response
     */
    'refills': Array<Refill>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedRefills200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedRefills200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedRefills200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetDeletedTransactions200Response
 */
export interface GetDeletedTransactions200Response {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof GetDeletedTransactions200Response
     */
    'transactions': Array<Transaction>;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedTransactions200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedTransactions200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetDeletedTransactions200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetRefills200Response
 */
export interface GetRefills200Response {
    /**
     * 
     * @type {Array<Refill>}
     * @memberof GetRefills200Response
     */
    'refills'?: Array<Refill>;
    /**
     * 
     * @type {number}
     * @memberof GetRefills200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRefills200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetRefills200Response
     */
    'max_page'?: number;
}
/**
 * 
 * @export
 * @interface GetSelfRefills200Response
 */
export interface GetSelfRefills200Response {
    /**
     * 
     * @type {Array<Refill>}
     * @memberof GetSelfRefills200Response
     */
    'refills'?: Array<Refill>;
    /**
     * 
     * @type {number}
     * @memberof GetSelfRefills200Response
     */
    'page': number;
    /**
     * 
     * @type {number}
     * @memberof GetSelfRefills200Response
     */
    'limit': number;
    /**
     * 
     * @type {number}
     * @memberof GetSelfRefills200Response
     */
    'max_page': number;
}
/**
 * 
 * @export
 * @interface GetTransactions200Response
 */
export interface GetTransactions200Response {
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof GetTransactions200Response
     */
    'transactions'?: Array<Transaction>;
    /**
     * 
     * @type {number}
     * @memberof GetTransactions200Response
     */
    'page'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactions200Response
     */
    'limit'?: number;
    /**
     * 
     * @type {number}
     * @memberof GetTransactions200Response
     */
    'max_page'?: number;
}
/**
 * 
 * @export
 * @interface HTTPError
 */
export interface HTTPError {
    /**
     * 
     * @type {Messages}
     * @memberof HTTPError
     */
    'message': Messages;
    /**
     * 
     * @type {ErrorCodes}
     * @memberof HTTPError
     */
    'error_code': ErrorCodes;
}


/**
 * 
 * @export
 * @interface ImportAccounts200Response
 */
export interface ImportAccounts200Response {
    /**
     * 
     * @type {Messages}
     * @memberof ImportAccounts200Response
     */
    'message'?: Messages;
    /**
     * 
     * @type {Array<string>}
     * @memberof ImportAccounts200Response
     */
    'not_accepted'?: Array<string>;
}


/**
 * 
 * @export
 * @interface Item
 */
export interface Item {
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'promotion'?: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'promotion_ends_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'amount_left': number;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'buy_limit': number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'category_id': string;
    /**
     * Name of the current item
     * @type {string}
     * @memberof Item
     */
    'name': string;
    /**
     * Link to picture of the current item
     * @type {string}
     * @memberof Item
     */
    'picture_uri': string;
    /**
     * 
     * @type {ItemState}
     * @memberof Item
     */
    'state': ItemState;
    /**
     * 
     * @type {number}
     * @memberof Item
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Item
     */
    'deleted_by'?: string;
}


/**
 * State of the item
 * @export
 * @enum {string}
 */

export const ItemState = {
    ItemBuyable: 'buyable',
    ItemNotBuyable: 'not_buyable'
} as const;

export type ItemState = typeof ItemState[keyof typeof ItemState];


/**
 * 
 * @export
 * @enum {string}
 */

export const Messages = {
    MsgBadRequest: 'Bad request',
    MsgNotConnected: 'Not connected',
    MsgMissingFields: 'Missing fields %v',
    MsgAccountAlreadyExists: 'Account already exists',
    MsgAccountNotFound: 'Account not found',
    MsgAccountNotAllowed: 'Account is not allowed to use ressource',
    MsgAccountNotAvailable: 'Account cannot use ressource at the time being',
    MsgQRInvalid: 'Invalid QR Code nonce',
    MsgInternalServerError: 'Internal server error',
    MsgNotAuthenticated: 'You are not authenticated',
    MsgImageNotFound: 'Image does not exists',
    MsgTextNotFound: 'Text does not exists',
    MsgCategoryNotFound: 'Category does not exists',
    MsgItemNotFound: 'Item does not exists',
    MsgRefillNotFound: 'Refill does not exists',
    MsgTransactionNotFound: 'Transaction does not exists'
} as const;

export type Messages = typeof Messages[keyof typeof Messages];


/**
 * 
 * @export
 * @interface NewAccount
 */
export interface NewAccount {
    /**
     * 
     * @type {string}
     * @memberof NewAccount
     */
    'first_name': string;
    /**
     * 
     * @type {string}
     * @memberof NewAccount
     */
    'last_name': string;
    /**
     * 
     * @type {string}
     * @memberof NewAccount
     */
    'email_address': string;
    /**
     * 
     * @type {string}
     * @memberof NewAccount
     */
    'card_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof NewAccount
     */
    'balance': number;
    /**
     * 
     * @type {AccountRole}
     * @memberof NewAccount
     */
    'role': AccountRole;
}


/**
 * 
 * @export
 * @interface NewCategory
 */
export interface NewCategory {
    /**
     * Name of the current category
     * @type {string}
     * @memberof NewCategory
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof NewCategory
     */
    'picture': string;
}
/**
 * 
 * @export
 * @interface NewItem
 */
export interface NewItem {
    /**
     * 
     * @type {number}
     * @memberof NewItem
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof NewItem
     */
    'promotion'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewItem
     */
    'promotion_ends_at'?: number;
    /**
     * 
     * @type {number}
     * @memberof NewItem
     */
    'amount_left': number;
    /**
     * 
     * @type {number}
     * @memberof NewItem
     */
    'buy_limit': number;
    /**
     * Name of the current item
     * @type {string}
     * @memberof NewItem
     */
    'name': string;
    /**
     * Picture of the current item
     * @type {string}
     * @memberof NewItem
     */
    'picture': string;
    /**
     * 
     * @type {ItemState}
     * @memberof NewItem
     */
    'state': ItemState;
}


/**
 * 
 * @export
 * @interface NewTransaction
 */
export interface NewTransaction {
    /**
     * 
     * @type {Array<NewTransactionItem>}
     * @memberof NewTransaction
     */
    'items': Array<NewTransactionItem>;
    /**
     * Pin of the card
     * @type {string}
     * @memberof NewTransaction
     */
    'card_pin': string;
}
/**
 * 
 * @export
 * @interface NewTransactionItem
 */
export interface NewTransactionItem {
    /**
     * 
     * @type {string}
     * @memberof NewTransactionItem
     */
    'item_id': string;
    /**
     * 
     * @type {number}
     * @memberof NewTransactionItem
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface PatchAccountRequest
 */
export interface PatchAccountRequest {
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRequest
     */
    'old_card_pin': string;
    /**
     * 
     * @type {string}
     * @memberof PatchAccountRequest
     */
    'new_card_pin': string;
}
/**
 * 
 * @export
 * @interface Refill
 */
export interface Refill {
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'account_id': string;
    /**
     * Name of the account
     * @type {string}
     * @memberof Refill
     */
    'account_name': string;
    /**
     * 
     * @type {number}
     * @memberof Refill
     */
    'amount': number;
    /**
     * 
     * @type {RefillState}
     * @memberof Refill
     */
    'state': RefillState;
    /**
     * 
     * @type {number}
     * @memberof Refill
     */
    'issued_at': number;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'issued_by': string;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'issued_by_name': string;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'canceled_by'?: string;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'canceled_by_name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Refill
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Refill
     */
    'deleted_by'?: string;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const RefillState = {
    Valid: 'valid',
    Canceled: 'canceled'
} as const;

export type RefillState = typeof RefillState[keyof typeof RefillState];


/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * 
     * @type {Array<TransactionItem>}
     * @memberof Transaction
     */
    'items': Array<TransactionItem>;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'account_id': string;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'total_cost': number;
    /**
     * 
     * @type {TransactionState}
     * @memberof Transaction
     */
    'state': TransactionState;
    /**
     * 
     * @type {number}
     * @memberof Transaction
     */
    'deleted_at'?: number;
    /**
     * 
     * @type {string}
     * @memberof Transaction
     */
    'deleted_by'?: string;
}


/**
 * 
 * @export
 * @interface TransactionItem
 */
export interface TransactionItem {
    /**
     * 
     * @type {string}
     * @memberof TransactionItem
     */
    'item_id': string;
    /**
     * Link to picture of the current item
     * @type {string}
     * @memberof TransactionItem
     */
    'picture_uri': string;
    /**
     * Name of the current item
     * @type {string}
     * @memberof TransactionItem
     */
    'item_name': string;
    /**
     * 
     * @type {number}
     * @memberof TransactionItem
     */
    'item_amount': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionItem
     */
    'unit_cost': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionItem
     */
    'total_cost': number;
    /**
     * 
     * @type {TransactionItemState}
     * @memberof TransactionItem
     */
    'state': TransactionItemState;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionItemState = {
    TransactionItemStarted: 'started',
    TransactionItemTakenCareOf: 'taken_care_of',
    TransactionItemFinished: 'finished',
    TransactionItemCanceled: 'canceled'
} as const;

export type TransactionItemState = typeof TransactionItemState[keyof typeof TransactionItemState];


/**
 * 
 * @export
 * @enum {string}
 */

export const TransactionState = {
    TransactionStarted: 'started',
    TransactionTakenCareOf: 'taken_care_of',
    TransactionFinished: 'finished',
    TransactionCanceled: 'canceled'
} as const;

export type TransactionState = typeof TransactionState[keyof typeof TransactionState];


/**
 * 
 * @export
 * @interface UpdateAccountAdmin
 */
export interface UpdateAccountAdmin {
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountAdmin
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountAdmin
     */
    'last_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountAdmin
     */
    'email_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAccountAdmin
     */
    'card_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateAccountAdmin
     */
    'balance'?: number;
    /**
     * 
     * @type {AccountRole}
     * @memberof UpdateAccountAdmin
     */
    'role'?: AccountRole;
    /**
     * 
     * @type {Array<AccountRestrictions>}
     * @memberof UpdateAccountAdmin
     */
    'restrictions'?: Array<AccountRestrictions>;
    /**
     * 
     * @type {AccountState}
     * @memberof UpdateAccountAdmin
     */
    'state'?: AccountState;
}


/**
 * 
 * @export
 * @interface UpdateCategory
 */
export interface UpdateCategory {
    /**
     * Name of the current category
     * @type {string}
     * @memberof UpdateCategory
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateCategory
     */
    'picture'?: string;
}
/**
 * 
 * @export
 * @interface UpdateItem
 */
export interface UpdateItem {
    /**
     * 
     * @type {number}
     * @memberof UpdateItem
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateItem
     */
    'amount_left'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateItem
     */
    'buy_limit'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateItem
     */
    'category_id'?: string;
    /**
     * Name of the current item
     * @type {string}
     * @memberof UpdateItem
     */
    'name'?: string;
    /**
     * Picture of the current item
     * @type {string}
     * @memberof UpdateItem
     */
    'picture'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateItem
     */
    'promotion'?: number;
    /**
     * 
     * @type {number}
     * @memberof UpdateItem
     */
    'promotion_ends_at'?: number;
    /**
     * 
     * @type {ItemState}
     * @memberof UpdateItem
     */
    'state'?: ItemState;
}



/**
 * AccountsApi - axios parameter creator
 * @export
 */
export const AccountsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountId: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAccounts: async (file?: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/import/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication admin_auth required


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteAccountId: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update\'s account card pin
         * @param {PatchAccountRequest} [patchAccountRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccount: async (patchAccountRequest?: PatchAccountRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(patchAccountRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountId: async (accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchAccountId', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountAdmin, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccounts: async (newAccount?: NewAccount, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newAccount, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountsApi - functional programming interface
 * @export
 */
export const AccountsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccount(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountId(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountId(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccounts(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccounts(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importAccounts(file?: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImportAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importAccounts(file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteAccountId(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteAccountId(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update\'s account card pin
         * @param {PatchAccountRequest} [patchAccountRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccount(patchAccountRequest?: PatchAccountRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccount(patchAccountRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccountId(accountId, updateAccountAdmin, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postAccounts(newAccount?: NewAccount, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postAccounts(newAccount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AccountsApi - factory interface
 * @export
 */
export const AccountsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountsApiFp(configuration)
    return {
        /**
         * Get the basic current account\'s information
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccount(options?: any): AxiosPromise<ConnectCard200Response> {
            return localVarFp.getAccount(options).then((request) => request(axios, basePath));
        },
        /**
         * Get the account\'s information
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountId(accountId: string, options?: any): AxiosPromise<Account> {
            return localVarFp.getAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all accounts informations
         * @summary 
         * @param {number} [page] page to get
         * @param {number} [limit] number of accounts to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccounts(page?: number, limit?: number, options?: any): AxiosPromise<GetAccounts200Response> {
            return localVarFp.getAccounts(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Import accounts from a CSV file
         * @summary 
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importAccounts(file?: File, options?: any): AxiosPromise<ImportAccounts200Response> {
            return localVarFp.importAccounts(file, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteAccountId(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteAccountId(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update\'s account card pin
         * @param {PatchAccountRequest} [patchAccountRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccount(patchAccountRequest?: PatchAccountRequest, options?: any): AxiosPromise<ConnectCard200Response> {
            return localVarFp.patchAccount(patchAccountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update account
         * @summary 
         * @param {string} accountId ID of the account
         * @param {UpdateAccountAdmin} [updateAccountAdmin] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: any): AxiosPromise<Account> {
            return localVarFp.patchAccountId(accountId, updateAccountAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * Add an account to the database
         * @summary 
         * @param {NewAccount} [newAccount] Add an account to the database
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postAccounts(newAccount?: NewAccount, options?: any): AxiosPromise<Account> {
            return localVarFp.postAccounts(newAccount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountsApi - object-oriented interface
 * @export
 * @class AccountsApi
 * @extends {BaseAPI}
 */
export class AccountsApi extends BaseAPI {
    /**
     * Get the basic current account\'s information
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccount(options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the account\'s information
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccountId(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all accounts informations
     * @summary 
     * @param {number} [page] page to get
     * @param {number} [limit] number of accounts to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public getAccounts(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).getAccounts(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Import accounts from a CSV file
     * @summary 
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public importAccounts(file?: File, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).importAccounts(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete account
     * @summary 
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public markDeleteAccountId(accountId: string, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).markDeleteAccountId(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update\'s account card pin
     * @param {PatchAccountRequest} [patchAccountRequest] Card pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public patchAccount(patchAccountRequest?: PatchAccountRequest, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).patchAccount(patchAccountRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update account
     * @summary 
     * @param {string} accountId ID of the account
     * @param {UpdateAccountAdmin} [updateAccountAdmin] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public patchAccountId(accountId: string, updateAccountAdmin?: UpdateAccountAdmin, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).patchAccountId(accountId, updateAccountAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add an account to the database
     * @summary 
     * @param {NewAccount} [newAccount] Add an account to the database
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountsApi
     */
    public postAccounts(newAccount?: NewAccount, options?: AxiosRequestConfig) {
        return AccountsApiFp(this.configuration).postAccounts(newAccount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (code: string, state: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('callback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callback', 'state', state)
            const localVarPath = `/auth/google/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount: async (qrNonce: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'qrNonce' is not null or undefined
            assertParamExists('connectAccount', 'qrNonce', qrNonce)
            const localVarPath = `/auth/google/begin/{qr_nonce}`
                .replace(`{${"qr_nonce"}}`, encodeURIComponent(String(qrNonce)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCard: async (connectCardRequest?: ConnectCardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/card`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication local_token required
            await setApiKeyToObject(localVarHeaderParameter, "X-Local-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(connectCardRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGoogle: async (r: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'r' is not null or undefined
            assertParamExists('connectGoogle', 'r', r)
            const localVarPath = `/auth/google`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (r !== undefined) {
                localVarQueryParameter['r'] = r;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQR: async (getAccountQRRequest?: GetAccountQRRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccountQRRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(code: string, state: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(code, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectAccount(qrNonce: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectAccount(qrNonce, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectCard(connectCardRequest?: ConnectCardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConnectCard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectCard(connectCardRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async connectGoogle(r: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.connectGoogle(r, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountQR(getAccountQRRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Callback for Google OAuth
         * @summary 
         * @param {string} code Google OAuth code
         * @param {string} state Google OAuth state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(code: string, state: string, options?: any): AxiosPromise<void> {
            return localVarFp.callback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} qrNonce QR nonce
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectAccount(qrNonce: string, options?: any): AxiosPromise<void> {
            return localVarFp.connectAccount(qrNonce, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to card
         * @summary 
         * @param {ConnectCardRequest} [connectCardRequest] Card id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectCard(connectCardRequest?: ConnectCardRequest, options?: any): AxiosPromise<ConnectCard200Response> {
            return localVarFp.connectCard(connectCardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Connect account to Google
         * @summary 
         * @param {string} r Redirect to this url after connecting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        connectGoogle(r: string, options?: any): AxiosPromise<void> {
            return localVarFp.connectGoogle(r, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the QR code to connect account to Google
         * @summary 
         * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: any): AxiosPromise<string> {
            return localVarFp.getAccountQR(getAccountQRRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Logout
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logout(options?: any): AxiosPromise<void> {
            return localVarFp.logout(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Callback for Google OAuth
     * @summary 
     * @param {string} code Google OAuth code
     * @param {string} state Google OAuth state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public callback(code: string, state: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).callback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to Google
     * @summary 
     * @param {string} qrNonce QR nonce
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connectAccount(qrNonce: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectAccount(qrNonce, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to card
     * @summary 
     * @param {ConnectCardRequest} [connectCardRequest] Card id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connectCard(connectCardRequest?: ConnectCardRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectCard(connectCardRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Connect account to Google
     * @summary 
     * @param {string} r Redirect to this url after connecting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public connectGoogle(r: string, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).connectGoogle(r, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the QR code to connect account to Google
     * @summary 
     * @param {GetAccountQRRequest} [getAccountQRRequest] Card pin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAccountQR(getAccountQRRequest?: GetAccountQRRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAccountQR(getAccountQRRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Logout
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public logout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).logout(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CarouselApi - axios parameter creator
 * @export
 */
export const CarouselApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselImage: async (image: File, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'image' is not null or undefined
            assertParamExists('addCarouselImage', 'image', image)
            const localVarPath = `/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication admin_auth required


            if (image !== undefined) { 
                localVarFormParams.append('image', image as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselText: async (carouselTextCreate: CarouselTextCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'carouselTextCreate' is not null or undefined
            assertParamExists('addCarouselText', 'carouselTextCreate', carouselTextCreate)
            const localVarPath = `/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(carouselTextCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImage: async (imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('getCarouselImage', 'imageId', imageId)
            const localVarPath = `/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImages: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselTexts: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselImage: async (imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('markDeleteCarouselImage', 'imageId', imageId)
            const localVarPath = `/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselText: async (textId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('markDeleteCarouselText', 'textId', textId)
            const localVarPath = `/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CarouselApi - functional programming interface
 * @export
 */
export const CarouselApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CarouselApiAxiosParamCreator(configuration)
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCarouselImage(image: File, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarouselImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCarouselImage(image, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCarouselText(carouselTextCreate: CarouselTextCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CarouselText>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCarouselText(carouselTextCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselImage(imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselImage(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselImages(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarouselImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselImages(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCarouselTexts(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CarouselText>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCarouselTexts(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCarouselImage(imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCarouselImage(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCarouselText(textId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCarouselText(textId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CarouselApi - factory interface
 * @export
 */
export const CarouselApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CarouselApiFp(configuration)
    return {
        /**
         * Add a carousel image
         * @param {File} image Image to display
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselImage(image: File, options?: any): AxiosPromise<CarouselImage> {
            return localVarFp.addCarouselImage(image, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a carousel text
         * @param {CarouselTextCreate} carouselTextCreate Carousel text object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCarouselText(carouselTextCreate: CarouselTextCreate, options?: any): AxiosPromise<CarouselText> {
            return localVarFp.addCarouselText(carouselTextCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImage(imageId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get carousel images
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselImages(options?: any): AxiosPromise<Array<CarouselImage>> {
            return localVarFp.getCarouselImages(options).then((request) => request(axios, basePath));
        },
        /**
         * Get carousel texts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCarouselTexts(options?: any): AxiosPromise<Array<CarouselText>> {
            return localVarFp.getCarouselTexts(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a carousel image
         * @param {string} imageId ID of the image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselImage(imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a carousel text
         * @param {string} textId ID of the text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCarouselText(textId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteCarouselText(textId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CarouselApi - object-oriented interface
 * @export
 * @class CarouselApi
 * @extends {BaseAPI}
 */
export class CarouselApi extends BaseAPI {
    /**
     * Add a carousel image
     * @param {File} image Image to display
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public addCarouselImage(image: File, options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).addCarouselImage(image, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a carousel text
     * @param {CarouselTextCreate} carouselTextCreate Carousel text object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public addCarouselText(carouselTextCreate: CarouselTextCreate, options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).addCarouselText(carouselTextCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a carousel image
     * @param {string} imageId ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public getCarouselImage(imageId: string, options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get carousel images
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public getCarouselImages(options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselImages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get carousel texts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public getCarouselTexts(options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).getCarouselTexts(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a carousel image
     * @param {string} imageId ID of the image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public markDeleteCarouselImage(imageId: string, options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).markDeleteCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a carousel text
     * @param {string} textId ID of the text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CarouselApi
     */
    public markDeleteCarouselText(textId: string, options?: AxiosRequestConfig) {
        return CarouselApiFp(this.configuration).markDeleteCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CategoriesApi - axios parameter creator
 * @export
 */
export const CategoriesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory: async (categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategory', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryPicture: async (categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryPicture', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}/picture`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCategory: async (categoryId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('markDeleteCategory', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCategory: async (categoryId: string, updateCategory: UpdateCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('patchCategory', 'categoryId', categoryId)
            // verify required parameter 'updateCategory' is not null or undefined
            assertParamExists('patchCategory', 'updateCategory', updateCategory)
            const localVarPath = `/categories/{category_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategory: async (newCategory: NewCategory, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'newCategory' is not null or undefined
            assertParamExists('postCategory', 'newCategory', newCategory)
            const localVarPath = `/categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newCategory, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoriesApi - functional programming interface
 * @export
 */
export const CategoriesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CategoriesApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategories(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Category>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategories(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategory(categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategory(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryPicture(categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryPicture(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteCategory(categoryId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteCategory(categoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchCategory(categoryId, updateCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCategory(newCategory: NewCategory, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Category>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCategory(newCategory, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CategoriesApi - factory interface
 * @export
 */
export const CategoriesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CategoriesApiFp(configuration)
    return {
        /**
         * Get all categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(options?: any): AxiosPromise<Array<Category>> {
            return localVarFp.getCategories(options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategory(categoryId: string, options?: any): AxiosPromise<Category> {
            return localVarFp.getCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a category picture
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryPicture(categoryId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getCategoryPicture(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a category
         * @param {string} categoryId ID of the category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteCategory(categoryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteCategory(categoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a category
         * @param {string} categoryId ID of the category
         * @param {UpdateCategory} updateCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: any): AxiosPromise<Category> {
            return localVarFp.patchCategory(categoryId, updateCategory, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new category
         * @param {NewCategory} newCategory Category object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCategory(newCategory: NewCategory, options?: any): AxiosPromise<Category> {
            return localVarFp.postCategory(newCategory, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CategoriesApi - object-oriented interface
 * @export
 * @class CategoriesApi
 * @extends {BaseAPI}
 */
export class CategoriesApi extends BaseAPI {
    /**
     * Get all categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategories(options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategories(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategory(categoryId: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a category picture
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public getCategoryPicture(categoryId: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).getCategoryPicture(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a category
     * @param {string} categoryId ID of the category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public markDeleteCategory(categoryId: string, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).markDeleteCategory(categoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a category
     * @param {string} categoryId ID of the category
     * @param {UpdateCategory} updateCategory Category object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public patchCategory(categoryId: string, updateCategory: UpdateCategory, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).patchCategory(categoryId, updateCategory, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new category
     * @param {NewCategory} newCategory Category object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoriesApi
     */
    public postCategory(newCategory: NewCategory, options?: AxiosRequestConfig) {
        return CategoriesApiFp(this.configuration).postCategory(newCategory, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQRWebsocket: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/qr`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccountAdmin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountQRWebsocket(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountQRWebsocket(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Check if the current account can access the admin panel
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountAdmin(options?: any): AxiosPromise<GetAccountAdmin200Response> {
            return localVarFp.getAccountAdmin(options).then((request) => request(axios, basePath));
        },
        /**
         * Websocket to listen for scan & callback (for cool animations)
         * @summary 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountQRWebsocket(options?: any): AxiosPromise<void> {
            return localVarFp.getAccountQRWebsocket(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Check if the current account can access the admin panel
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountAdmin(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccountAdmin(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Websocket to listen for scan & callback (for cool animations)
     * @summary 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccountQRWebsocket(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccountQRWebsocket(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DeletedApi - axios parameter creator
 * @export
 */
export const DeletedApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('deleteAccount', 'accountId', accountId)
            const localVarPath = `/deleted/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselImage: async (imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('deleteCarouselImage', 'imageId', imageId)
            const localVarPath = `/deleted/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselText: async (textId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('deleteCarouselText', 'textId', textId)
            const localVarPath = `/deleted/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem: async (itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('deleteItem', 'itemId', itemId)
            const localVarPath = `/deleted/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill: async (refillId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('deleteRefill', 'refillId', refillId)
            const localVarPath = `/deleted/refills/{refill_id}`
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('deleteTransaction', 'transactionId', transactionId)
            const localVarPath = `/deleted/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedAccounts: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselImages: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/carousel/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselTexts: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/carousel/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedItems: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/items`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedRefills: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedTransactions: async (page?: number, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleted/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedAccount: async (accountId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('restoreDeletedAccount', 'accountId', accountId)
            const localVarPath = `/deleted/accounts/{account_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselImage: async (imageId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('restoreDeletedCarouselImage', 'imageId', imageId)
            const localVarPath = `/deleted/carousel/images/{image_id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselText: async (textId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('restoreDeletedCarouselText', 'textId', textId)
            const localVarPath = `/deleted/carousel/texts/{text_id}`
                .replace(`{${"text_id"}}`, encodeURIComponent(String(textId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedItem: async (itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('restoreDeletedItem', 'itemId', itemId)
            const localVarPath = `/deleted/items/{item_id}`
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedRefill: async (refillId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('restoreDeletedRefill', 'refillId', refillId)
            const localVarPath = `/deleted/refills/{refill_id}`
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedTransaction: async (transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('restoreDeletedTransaction', 'transactionId', transactionId)
            const localVarPath = `/deleted/transactions/{transaction_id}`
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DeletedApi - functional programming interface
 * @export
 */
export const DeletedApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DeletedApiAxiosParamCreator(configuration)
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCarouselImage(imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarouselImage(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCarouselText(textId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCarouselText(textId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteItem(itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteItem(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRefill(refillId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRefill(refillId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedAccounts(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedAccounts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedAccounts(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedCarouselImages(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedCarouselImages200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedCarouselImages(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedCarouselTexts(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedCarouselTexts200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedCarouselTexts(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedItems(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedItems(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedRefills(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedRefills(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDeletedTransactions(page?: number, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDeletedTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDeletedTransactions(page, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedAccount(accountId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedAccount(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedCarouselImage(imageId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedCarouselImage(imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedCarouselText(textId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedCarouselText(textId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedItem(itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedItem(itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedRefill(refillId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedRefill(refillId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async restoreDeletedTransaction(transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.restoreDeletedTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DeletedApi - factory interface
 * @export
 */
export const DeletedApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DeletedApiFp(configuration)
    return {
        /**
         * Permanently deletes an account (SUPERADMIN)
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccount(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a carousel image (SUPERADMIN)
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselImage(imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a carousel text (SUPERADMIN)
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCarouselText(textId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteCarouselText(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes an item (SUPERADMIN)
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteItem(itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a refill (SUPERADMIN)
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRefill(refillId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteRefill(refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Permanently deletes a transaction (SUPERADMIN)
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTransaction(transactionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted accounts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedAccounts(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedAccounts200Response> {
            return localVarFp.getDeletedAccounts(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted carousel images
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselImages(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedCarouselImages200Response> {
            return localVarFp.getDeletedCarouselImages(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted carousel texts
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedCarouselTexts(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedCarouselTexts200Response> {
            return localVarFp.getDeletedCarouselTexts(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted items
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedItems(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedItems200Response> {
            return localVarFp.getDeletedItems(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedRefills(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedRefills200Response> {
            return localVarFp.getDeletedRefills(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Get deleted transactions
         * @param {number} [page] Page number
         * @param {number} [limit] Number of accounts per page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDeletedTransactions(page?: number, limit?: number, options?: any): AxiosPromise<GetDeletedTransactions200Response> {
            return localVarFp.getDeletedTransactions(page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted account
         * @param {string} accountId ID of the account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedAccount(accountId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedAccount(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted carousel image
         * @param {string} imageId ID of the carousel image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselImage(imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedCarouselImage(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted carousel text
         * @param {string} textId ID of the carousel text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedCarouselText(textId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedCarouselText(textId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted item
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedItem(itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedItem(itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted refill
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedRefill(refillId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedRefill(refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Restore a deleted transaction
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        restoreDeletedTransaction(transactionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.restoreDeletedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DeletedApi - object-oriented interface
 * @export
 * @class DeletedApi
 * @extends {BaseAPI}
 */
export class DeletedApi extends BaseAPI {
    /**
     * Permanently deletes an account (SUPERADMIN)
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteAccount(accountId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a carousel image (SUPERADMIN)
     * @param {string} imageId ID of the carousel image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteCarouselImage(imageId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a carousel text (SUPERADMIN)
     * @param {string} textId ID of the carousel text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteCarouselText(textId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes an item (SUPERADMIN)
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteItem(itemId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a refill (SUPERADMIN)
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteRefill(refillId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteRefill(refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Permanently deletes a transaction (SUPERADMIN)
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public deleteTransaction(transactionId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).deleteTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted accounts
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedAccounts(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedAccounts(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted carousel images
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedCarouselImages(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedCarouselImages(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted carousel texts
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedCarouselTexts(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedCarouselTexts(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted items
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedItems(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedItems(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedRefills(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedRefills(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get deleted transactions
     * @param {number} [page] Page number
     * @param {number} [limit] Number of accounts per page
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public getDeletedTransactions(page?: number, limit?: number, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).getDeletedTransactions(page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted account
     * @param {string} accountId ID of the account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedAccount(accountId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedAccount(accountId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted carousel image
     * @param {string} imageId ID of the carousel image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedCarouselImage(imageId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedCarouselImage(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted carousel text
     * @param {string} textId ID of the carousel text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedCarouselText(textId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedCarouselText(textId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted item
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedItem(itemId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedItem(itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted refill
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedRefill(refillId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedRefill(refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Restore a deleted transaction
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DeletedApi
     */
    public restoreDeletedTransaction(transactionId: string, options?: AxiosRequestConfig) {
        return DeletedApiFp(this.configuration).restoreDeletedTransaction(transactionId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ItemsApi - axios parameter creator
 * @export
 */
export const ItemsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems: async (categoryId: string, page?: number, limit?: number, state?: ItemState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getCategoryItems', 'categoryId', categoryId)
            const localVarPath = `/categories/{category_id}/items`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemPicture: async (categoryId: string, itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getItemPicture', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('getItemPicture', 'itemId', itemId)
            const localVarPath = `/categories/{category_id}/items/{item_id}/picture`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteItem: async (categoryId: string, itemId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('markDeleteItem', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('markDeleteItem', 'itemId', itemId)
            const localVarPath = `/categories/{category_id}/items/{item_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItem: async (categoryId: string, itemId: string, updateItem: UpdateItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('patchItem', 'categoryId', categoryId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('patchItem', 'itemId', itemId)
            // verify required parameter 'updateItem' is not null or undefined
            assertParamExists('patchItem', 'updateItem', updateItem)
            const localVarPath = `/categories/{category_id}/items/{item_id}`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItem: async (categoryId: string, newItem: NewItem, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('postItem', 'categoryId', categoryId)
            // verify required parameter 'newItem' is not null or undefined
            assertParamExists('postItem', 'newItem', newItem)
            const localVarPath = `/categories/{category_id}/items`
                .replace(`{${"category_id"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newItem, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ItemsApi - functional programming interface
 * @export
 */
export const ItemsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ItemsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCategoryItems200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCategoryItems(categoryId, page, limit, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getItemPicture(categoryId: string, itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getItemPicture(categoryId, itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteItem(categoryId: string, itemId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteItem(categoryId, itemId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchItem(categoryId, itemId, updateItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postItem(categoryId: string, newItem: NewItem, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Item>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postItem(categoryId, newItem, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ItemsApi - factory interface
 * @export
 */
export const ItemsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ItemsApiFp(configuration)
    return {
        /**
         * Get all items of a category
         * @param {string} categoryId ID of the category
         * @param {number} [page] Page number
         * @param {number} [limit] Number of items per page
         * @param {ItemState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: any): AxiosPromise<GetCategoryItems200Response> {
            return localVarFp.getCategoryItems(categoryId, page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an item picture
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getItemPicture(categoryId: string, itemId: string, options?: any): AxiosPromise<File> {
            return localVarFp.getItemPicture(categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteItem(categoryId: string, itemId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteItem(categoryId, itemId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an item
         * @param {string} categoryId ID of the category
         * @param {string} itemId ID of the item
         * @param {UpdateItem} updateItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: any): AxiosPromise<Item> {
            return localVarFp.patchItem(categoryId, itemId, updateItem, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new item
         * @param {string} categoryId ID of the category
         * @param {NewItem} newItem Item object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postItem(categoryId: string, newItem: NewItem, options?: any): AxiosPromise<Item> {
            return localVarFp.postItem(categoryId, newItem, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ItemsApi - object-oriented interface
 * @export
 * @class ItemsApi
 * @extends {BaseAPI}
 */
export class ItemsApi extends BaseAPI {
    /**
     * Get all items of a category
     * @param {string} categoryId ID of the category
     * @param {number} [page] Page number
     * @param {number} [limit] Number of items per page
     * @param {ItemState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getCategoryItems(categoryId: string, page?: number, limit?: number, state?: ItemState, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getCategoryItems(categoryId, page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an item picture
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public getItemPicture(categoryId: string, itemId: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).getItemPicture(categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete an item
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public markDeleteItem(categoryId: string, itemId: string, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).markDeleteItem(categoryId, itemId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an item
     * @param {string} categoryId ID of the category
     * @param {string} itemId ID of the item
     * @param {UpdateItem} updateItem Item object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public patchItem(categoryId: string, itemId: string, updateItem: UpdateItem, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).patchItem(categoryId, itemId, updateItem, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new item
     * @param {string} categoryId ID of the category
     * @param {NewItem} newItem Item object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ItemsApi
     */
    public postItem(categoryId: string, newItem: NewItem, options?: AxiosRequestConfig) {
        return ItemsApiFp(this.configuration).postItem(categoryId, newItem, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RefillsApi - axios parameter creator
 * @export
 */
export const RefillsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRefills: async (accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountRefills', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/refills`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefills: async (page?: number, limit?: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRefills: async (page?: number, limit?: number, startDate?: string, endDate?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/refills`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['start_date'] = (startDate as any instanceof Date) ?
                    (startDate as any).toISOString().substr(0,10) :
                    startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['end_date'] = (endDate as any instanceof Date) ?
                    (endDate as any).toISOString().substr(0,10) :
                    endDate;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteRefill: async (accountId: string, refillId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteRefill', 'accountId', accountId)
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('markDeleteRefill', 'refillId', refillId)
            const localVarPath = `/accounts/{account_id}/refills/{refill_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} state New state of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRefillId: async (accountId: string, refillId: string, state: RefillState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchRefillId', 'accountId', accountId)
            // verify required parameter 'refillId' is not null or undefined
            assertParamExists('patchRefillId', 'refillId', refillId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('patchRefillId', 'state', state)
            const localVarPath = `/accounts/{account_id}/refills/{refill_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"refill_id"}}`, encodeURIComponent(String(refillId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRefill: async (accountId: string, amount: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('postRefill', 'accountId', accountId)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('postRefill', 'amount', amount)
            const localVarPath = `/accounts/{account_id}/refills`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RefillsApi - functional programming interface
 * @export
 */
export const RefillsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RefillsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRefills(accountId, page, limit, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefills(page, limit, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetSelfRefills200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSelfRefills(page, limit, startDate, endDate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteRefill(accountId: string, refillId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteRefill(accountId, refillId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} state New state of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchRefillId(accountId: string, refillId: string, state: RefillState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchRefillId(accountId, refillId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postRefill(accountId: string, amount: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Refill>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postRefill(accountId, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RefillsApi - factory interface
 * @export
 */
export const RefillsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RefillsApiFp(configuration)
    return {
        /**
         * Get all refills of an account
         * @param {string} accountId ID or CardID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<GetSelfRefills200Response> {
            return localVarFp.getAccountRefills(accountId, page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<GetRefills200Response> {
            return localVarFp.getRefills(page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all refills
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {string} [startDate] Start date of the refill
         * @param {string} [endDate] End date of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: any): AxiosPromise<GetSelfRefills200Response> {
            return localVarFp.getSelfRefills(page, limit, startDate, endDate, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancels a refill
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteRefill(accountId: string, refillId: string, options?: any): AxiosPromise<void> {
            return localVarFp.markDeleteRefill(accountId, refillId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update refill\'s state
         * @param {string} accountId ID of the account
         * @param {string} refillId ID of the refill
         * @param {RefillState} state New state of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchRefillId(accountId: string, refillId: string, state: RefillState, options?: any): AxiosPromise<Refill> {
            return localVarFp.patchRefillId(accountId, refillId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new refill
         * @param {string} accountId ID or CardID of the account
         * @param {number} amount Amount of the refill
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postRefill(accountId: string, amount: number, options?: any): AxiosPromise<Refill> {
            return localVarFp.postRefill(accountId, amount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RefillsApi - object-oriented interface
 * @export
 * @class RefillsApi
 * @extends {BaseAPI}
 */
export class RefillsApi extends BaseAPI {
    /**
     * Get all refills of an account
     * @param {string} accountId ID or CardID of the account
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public getAccountRefills(accountId: string, page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getAccountRefills(accountId, page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public getRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getRefills(page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all refills
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {string} [startDate] Start date of the refill
     * @param {string} [endDate] End date of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public getSelfRefills(page?: number, limit?: number, startDate?: string, endDate?: string, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).getSelfRefills(page, limit, startDate, endDate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancels a refill
     * @param {string} accountId ID of the account
     * @param {string} refillId ID of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public markDeleteRefill(accountId: string, refillId: string, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).markDeleteRefill(accountId, refillId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update refill\'s state
     * @param {string} accountId ID of the account
     * @param {string} refillId ID of the refill
     * @param {RefillState} state New state of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public patchRefillId(accountId: string, refillId: string, state: RefillState, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).patchRefillId(accountId, refillId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new refill
     * @param {string} accountId ID or CardID of the account
     * @param {number} amount Amount of the refill
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RefillsApi
     */
    public postRefill(accountId: string, amount: number, options?: AxiosRequestConfig) {
        return RefillsApiFp(this.configuration).postRefill(accountId, amount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TransactionsApi - axios parameter creator
 * @export
 */
export const TransactionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions: async (accountId: string, page?: number, limit?: number, state?: TransactionState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountTransactions', 'accountId', accountId)
            const localVarPath = `/accounts/{account_id}/transactions`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAccountTransactions: async (page?: number, limit?: number, state?: TransactionState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionId: async (accountId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getTransactionId', 'transactionId', transactionId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions: async (page?: number, limit?: number, state?: TransactionState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteTransactionId: async (accountId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('markDeleteTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('markDeleteTransactionId', 'transactionId', transactionId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionId: async (accountId: string, transactionId: string, state: TransactionState, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchTransactionId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('patchTransactionId', 'transactionId', transactionId)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('patchTransactionId', 'state', state)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionItemId: async (accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'accountId', accountId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'transactionId', transactionId)
            // verify required parameter 'itemId' is not null or undefined
            assertParamExists('patchTransactionItemId', 'itemId', itemId)
            const localVarPath = `/accounts/{account_id}/transactions/{transaction_id}/{item_id}`
                .replace(`{${"account_id"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"transaction_id"}}`, encodeURIComponent(String(transactionId)))
                .replace(`{${"item_id"}}`, encodeURIComponent(String(itemId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication admin_auth required

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactions: async (newTransaction?: NewTransaction, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication auth required


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(newTransaction, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TransactionsApi - functional programming interface
 * @export
 */
export const TransactionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TransactionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactions(accountId, page, limit, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentAccountTransactions(page, limit, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionId(accountId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionId(accountId, transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactions(page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactions(page, limit, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markDeleteTransactionId(accountId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markDeleteTransactionId(accountId, transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTransactionId(accountId, transactionId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HTTPError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchTransactionItemId(accountId, transactionId, itemId, state, amount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postTransactions(newTransaction?: NewTransaction, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transaction>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postTransactions(newTransaction, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TransactionsApi - factory interface
 * @export
 */
export const TransactionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TransactionsApiFp(configuration)
    return {
        /**
         * Get all transactions
         * @summary 
         * @param {string} accountId ID of the account
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: any): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getAccountTransactions(accountId, page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all transactions
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: any): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getCurrentAccountTransactions(page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Get transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionId(accountId: string, transactionId: string, options?: any): AxiosPromise<Transaction> {
            return localVarFp.getTransactionId(accountId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get all active transactions (orders)
         * @summary 
         * @param {number} [page] Page number
         * @param {number} [limit] Number of transactions per page
         * @param {TransactionState} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactions(page?: number, limit?: number, state?: TransactionState, options?: any): AxiosPromise<GetTransactions200Response> {
            return localVarFp.getTransactions(page, limit, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete transaction
         * @summary 
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markDeleteTransactionId(accountId: string, transactionId: string, options?: any): AxiosPromise<HTTPError> {
            return localVarFp.markDeleteTransactionId(accountId, transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update transaction\'s state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {TransactionState} state New state of the transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: any): AxiosPromise<HTTPError> {
            return localVarFp.patchTransactionId(accountId, transactionId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Update transaction\'s item state
         * @param {string} accountId ID of the account
         * @param {string} transactionId ID of the transaction
         * @param {string} itemId ID of the item
         * @param {TransactionItemState} [state] New state of the item
         * @param {number} [amount] New amount of the item
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, options?: any): AxiosPromise<HTTPError> {
            return localVarFp.patchTransactionItemId(accountId, transactionId, itemId, state, amount, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new transaction
         * @summary 
         * @param {NewTransaction} [newTransaction] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postTransactions(newTransaction?: NewTransaction, options?: any): AxiosPromise<Transaction> {
            return localVarFp.postTransactions(newTransaction, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TransactionsApi - object-oriented interface
 * @export
 * @class TransactionsApi
 * @extends {BaseAPI}
 */
export class TransactionsApi extends BaseAPI {
    /**
     * Get all transactions
     * @summary 
     * @param {string} accountId ID of the account
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getAccountTransactions(accountId: string, page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getAccountTransactions(accountId, page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all transactions
     * @summary 
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getCurrentAccountTransactions(page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getCurrentAccountTransactions(page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get transaction
     * @summary 
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactionId(accountId: string, transactionId: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactionId(accountId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get all active transactions (orders)
     * @summary 
     * @param {number} [page] Page number
     * @param {number} [limit] Number of transactions per page
     * @param {TransactionState} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public getTransactions(page?: number, limit?: number, state?: TransactionState, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).getTransactions(page, limit, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete transaction
     * @summary 
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public markDeleteTransactionId(accountId: string, transactionId: string, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).markDeleteTransactionId(accountId, transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update transaction\'s state
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {TransactionState} state New state of the transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public patchTransactionId(accountId: string, transactionId: string, state: TransactionState, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).patchTransactionId(accountId, transactionId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update transaction\'s item state
     * @param {string} accountId ID of the account
     * @param {string} transactionId ID of the transaction
     * @param {string} itemId ID of the item
     * @param {TransactionItemState} [state] New state of the item
     * @param {number} [amount] New amount of the item
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public patchTransactionItemId(accountId: string, transactionId: string, itemId: string, state?: TransactionItemState, amount?: number, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).patchTransactionItemId(accountId, transactionId, itemId, state, amount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new transaction
     * @summary 
     * @param {NewTransaction} [newTransaction] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionsApi
     */
    public postTransactions(newTransaction?: NewTransaction, options?: AxiosRequestConfig) {
        return TransactionsApiFp(this.configuration).postTransactions(newTransaction, options).then((request) => request(this.axios, this.basePath));
    }
}


